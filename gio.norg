* Gio configuration
  gio.nvim (기어.nvim) is a kickstart configuration, powered by {https://github.com/nvim-neorg/neorg}[Neorg].
  This file covers the `gio` module. It is not recommended to be edited by users.
  This is the only part of config that is recommended to be kept if you will going to use gio.nvim.

** plugin/bootstrap.lua
   This file is used to bootstrap important plugins.
   Current list:
   - {https://github.com/wbthomason/packer.nvim.git}[wbthomason/packer.nvim]
   - {https://github.com/udayvir-singh/tangerine.nvim}[udayvir-singh/tangerine.nvim]
   #tangle ./plugin/bootstrap.lua
   @code lua
   --- AUTOGENERATED FROM gio.norg
   @end

*** PACK_PATH
    This variable is the path for the plugin installation.
    #tangle ./plugin/bootstrap.lua
    @code lua
    local PACK_PATH = vim.fn.stdpath("data") .. "/site/pack"
    @end
*** ensure
    Function that installs a plugin using it's repository name and kind (opt/start).
    Kind fallbacks to opt.
    It checks whether plugin's destination is not empty and tries to clone a GitHub repository.
    #tangle ./plugin/bootstrap.lua
    @code lua
    local function ensure(repository, kind)
        kind = kind or "opt"
        local name = vim.split(repository, "/")[2]
        local destination = string.format(
            "%s/packer/%s/%s", PACK_PATH, kind, name
        )
        if vim.fn.empty(vim.fn.glob(destination)) > 0 then
            vim.notify("GIO: auto-installing " .. repository .. "...")
            vim.fn.system({
                "git", "clone", "--depth", "1",
                "https://github.com/" .. repository, destination,
            })
            if vim.v.shell_error ~= 0 then
                vim.notify(
                    "GIO: failed to auto-install " .. repository .. "...",
                    vim.log.levels.ERROR
                )
            else
                vim.notify("GIO: auto-installed " .. repository "...")
            end
        end
    end
    @end
*** is_installed
    Simple function to check whether plugin is installed outside of `ensure` function.
    #tangle ./plugin/bootstrap.lua
    @code lua
    local function is_installed(name, kind)
        kind = kind or "opt"
        return vim.fn.empty(vim.fn.glob(string.format("%s/packer/%s/%s", PACK_PATH, kind, name))) == 0
    end
    @end
*** Install plugins
    #tangle ./plugin/bootstrap.lua
    @code lua
    vim.defer_fn(function()
        ensure "wbthomason/packer.nvim"
        ensure "udayvir-singh/tangerine.nvim"

        if is_installed "tangerine.nvim" then
            vim.api.nvim_command "packadd tangerine.nvim"
            require("tangerine").setup {
                rtpdirs = { "after" },
                compiler = {
                    hooks = { "onsave", "oninit" }
                }
            }
        end

        vim.api.nvim_command "packadd packer.nvim"
    end, 0)
    @end

** init.lua
   This file exports util functions and autoinstalls packer.nvim
   #tangle ./lua/gio/init.lua
   @code lua
   --- AUTOGENERATED FROM gio.norg
   return {
       utils = require "gio.utils",
       tsinstall = require "gio.utils".tsinstall,
       plug = require "gio.plugin.manager".install,
       load_modules = require "gio.utils".autoload_modules,
       set = require "gio.utils".set,
   }
   @end
** utils.lua
   This file contains general util functions. Some functions are not exported.
   #tangle ./lua/gio/utils.lua
   @code lua
   --- AUTOGENERATED FROM gio.norg
   local utils = {}
   @end
*** tsinstall
    Public function, takes a table of TS parser names as argument.
    Provides a default TreeSitter config. If you want to configure TS properly, do not use this function.
    #tangle ./lua/gio/utils.lua
    @code lua
    function utils.tsinstall(languages)
        require("nvim-treesitter.configs").setup({
            ensure_installed = languages,
            highlight = { enable = true, },
        })
    end
    @end

*** get_config_path
    Private function. Kept as private and has some hardcoded parts because it is unstable and not recommended for usage.
    Returns absolute path to your neovim config. Useful in cases when you use tools like {https://github.com/ntbbloodbath/cheovim}[cheovim].
    #tangle ./lua/gio/utils.lua
    @code lua
    function get_config_path()
        return debug.getinfo(2, "S").source
        :sub(2)
        :gsub("\\", "/")
        :gsub("/lua/gio/utils.lua", "")
    end
    @end

*** autoload_modules
    Loads every module you have inside `./lua/modules`. You can use it to automatically bootstrap packer tables.
    Fetches config paths and gets list of every directory under `$config/lua/modules`.
    After that loads every module based on path.
    #tangle ./lua/gio/utils.lua
    @code lua
    function utils.autoload_modules()
        local path = get_config_path()
        local module_path = path.."/lua/modules/*"
        local modules = vim.split(vim.fn.expand(module_path), "\n")
        for _, module in pairs(modules) do
            module = module
            :gsub("\\", "/")
            :gsub(vim.pesc(path), "")
            :gsub("/lua/", "")
            require(module)
        end
    end
    @end
*** set
    A handy wrapper around `vim.opt`. Works like average `:set` command!
    Examples:
    - `set "nu"`
    - `set { "nu", "rnu" }`
    - `set { "nu" = true, "rnu" = true }`
    #tangle ./lua/gio/utils.lua
    @code lua
    function utils.set(opt)
        if type(opt) == "string" then
            if opt:sub(1, 2) == "no" then
                vim.opt[opt:sub(3)] = false
            else
                vim.opt[opt] = true
            end
        else
            if vim.tbl_islist(opt) then
                for _, option in ipairs(opt) do
                    if option:sub(1, 2) == "no" then
                        vim.opt[option:sub(3)] = false
                    else
                        vim.opt[option] = true
                    end
                end
            else
                for key, value in pairs(opt) do
                    vim.opt[key] = value
                end
            end
        end
    end
    @end
    ---
   #tangle ./lua/gio/utils.lua
   @code lua
   return utils
   @end

** gio.plugin module
   This module is used for functions and stuff directly related to the plugin management.
   Contains these files:
   - `manager.lua`
*** manager.lua
    This is where the magic happens.
    #tangle ./lua/gio/plugin/manager.lua
    @code lua
    --- AUTOGENERATED FROM gio.norg
    @end

**** packer variable
     This variable is private and is used for converting Manager.plugins into packerish format.
     #tangle ./lua/gio/plugin/manager.lua
     @code lua
     local packer = {}
     @end

**** Manager table
     This table is used for exporting `Manager.install` function and `Manager.plugins` variable.
     #tangle ./lua/gio/plugin/manager.lua
     @code lua
     local Manager = {
         plugins = {},
     }
     @end

**** Manager.plugins
     This table made public so user can set their plugin configurations. Syntax is pretty simple:
     @code lua
     require("gio.plugin.manager").plugins["module@/plugin_location"] = {
         -- packer.nvim configuration
     }
     @end
     The only thing we override inside packer.nvim configuration is `config` variable.
     @code lua
     -- snip
     config = "@neorg"
     -- snip
     @end
     This will be expanded to `require("modules.$module.neorg")`.
     Be careful when you use `@` char in your config strings!

**** Manager.install
     This one is a bit complex. Let's use an example config for this one.
     (the code is taken from `lua/modules/organization/init.lua`
     @code lua
     require("gio.plugin.manager").plugins["organization@nvim-neorg/neorg"] = {
         config = "@neorg",
         event = { "BufRead", "BufNewFile" },
         requires = { "nvim-treesitter" },
     }
     @end
     Now you might ask, why we even need the `organization@` part? Look closer at the `config` field:
     @code lua
     config = "@neorg",
     @end
     See that `@`? When `Manager.install` reads this key it gets expanded to `require("modules.%MODULE%.neorg")`.
     Be careful when you use `@` char!

     And now, about the function itself. It just iterates over `Manager.plugins` table, parses key, value's config field,
     and runs packer on the formatted plugin specifications.

     #tangle ./lua/gio/plugin/manager.lua
     @code lua
     function Manager.install()
         local _packer = {}
         local plugins = Manager.plugins
         for plugin_string, spec in pairs(plugins) do
             local module, location = unpack(vim.split(plugin_string, "@"))
             if vim.tbl_isempty(spec) then
                 table.insert(_packer, location)
             else
                 if type(spec.config) == "string" then
                     local _foo, _bar = string.find(spec.config, "@", 1, true)
                     if _foo ~= nil then
                         spec.config = [[require("modules.]] .. module .. "." .. spec.config:gsub("@", "") .. [[")]]
                     end
                 end
                 table.insert(_packer, vim.tbl_extend("force", {location}, spec))
             end
         end
         require("packer").startup(function(use)
             for _, specs in pairs(_packer) do
                 use(specs)
             end
             use "wbthomason/packer.nvim"
         end)
     end
     @end
     ---
    #tangle ./lua/gio/plugin/manager.lua
    @code lua
    return Manager
    @end
